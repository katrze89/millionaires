
#[pytanie 0]
#question =
#a =
#b =
#c =
#d =
#correct_ans =

[pytanie 1]
question = Które z nich nie jest zasadą oop
a = dziedziczenie
b = polimorfizm
c = encapsulation
d = pure function
correct_ans = d

[pytanie 2]
question = Dziedziczenie to
a = przeciążenie metod
b = kopiowanie pól i metod rodzica
c = access modifiers
d = metoda, która jest uruchamiana zawsze w momencie tworzenia obiektu
correct_ans = b

[pytanie 3]
question = Polimorfizm to
a = przeciążenie metod
b = kopiowanie pól i metod rodzica
c = access modifiers
d = metoda, która jest uruchamiana zawsze w momencie tworzenia obiektu
correct_ans = a

[pytanie 4]
question = Encapsulation to
a = przeciążenie metod
b = kopiowanie pól i metod rodzica
c = access modifiers
d = metoda, która jest uruchamiana zawsze w momencie tworzenia obiektu
correct_ans = c

[pytanie 5]
question = Jaki mamy rodzaje access modifiers
a = private, protected, public, read
b = non-public, protected, public, readonly
c = private, protected, public, readonly
d = unprotected, protected, public, readonly
correct_ans = c

[pytanie 6]
question = super() jest związany z którą zasadą oop
a = dziedziczenie
b = polimorfizm
c = encapsulation
d = pure function
correct_ans = a

[pytanie 7]
question = Konstruktor to:
a = schemat, plan
b = instancja, egzemplarz
c = metoda, która jest uruchamiana zawsze w momencie tworzenia obiektu
d = inicjalizator, uruchamiany zawsze w momencie tworzenia obiektu
correct_ans = c

[pytanie 8]
question = Klasa to:
a = schemat, plan
b = instancja, egzemplarz
c = funkcja w klasie
d = inicjalizator, uruchamiany zawsze w momencie tworzenia obiektu
correct_ans = a

[pytanie 9]
question = __ini__ to:
a = zmienne w klasie
b = instancja, egzemplarz
c = funkcja w klasie
d = inicjalizator, uruchamiany zawsze w momencie tworzenia obiektu
correct_ans = d

[pytanie 10]
question = Pole to:
a = zmienna w klasie
b = instancja, egzemplarz
c = funkcja w klasie
d = odnośnik/referencja do obiektu który powstanie
correct_ans = a

[pytanie 11]
question = Obiekt to:
a = zmienna w klasie
b = instancja, egzemplarz
c = funkcja w klasie
d = odnośnik/referencja do obiektu który powstanie
correct_ans = b

[pytanie 12]
question = Metoda to:
a = zmienna w klasie
b = instancja, egzemplarz
c = funkcja w klasie
d = odnośnik/referencja do obiektu który powstanie
correct_ans = c

[pytanie 13]
question = self to:
a = zmienna w klasie
b = instancja, egzemplarz
c = funkcja w klasie
d = odnośnik/referencja do obiektu który powstanie
correct_ans = d

[pytanie 14]
question = Wskaż zdanie falszywe (generatory)
a = generator ma co najmniej jednego yield
b = każdy generator jest iteratorem
c = generator nie może mieć return
d = generatory używane są do obsługi stream
correct_ans = c

[pytanie 15]
question = Wskaż zdanie falszywe (generatory)
a = generator ma co najmniej jednego yield
b = gdy używasz generatora to wszystkie dane są od razu wyliczane
c = generatory są lazy evaluated
d = generatory używane są do obsługi stream
correct_ans = b

[pytanie 16]
question = Wskaż zdanie falszywe na temat yield
a = generator ma co najmniej jednego yield
b = jest to return na sterydach
c = przerywa działanie
d = instrukcji yield jest warunkiem wystarczającym, aby funkcja stała się funkcją generującą
correct_ans = c

[pytanie 17]
question = Set jest
a = kolekcja, unordered, immutable, heterogeniczna
b = kolekcja, ordered, immutable, heterogeniczna
c = kolekcja, ordered, mutable, heterogeniczna
d = kolekcja, unordered, mutable, heterogeniczna
correct_ans = d

[pytanie 18]
question = Lista jest
a = kolekcja, unordered, immutable, heterogeniczna
b = kolekcja, ordered, immutable, heterogeniczna
c = kolekcja, ordered, mutable, heterogeniczna
d = kolekcja, unordered, mutable, heterogeniczna
correct_ans = c

[pytanie 19]
question = Tupla jest
a = kolekcja, unordered, immutable, heterogeniczna
b = kolekcja, ordered, immutable, heterogeniczna
c = kolekcja, ordered, mutable, heterogeniczna
d = kolekcja, unordered, mutable, heterogeniczna
correct_ans = b

[pytanie 20]
question = Frozenset jest
a = kolekcja, unordered, immutable, heterogeniczna
b = kolekcja, ordered, immutable, heterogeniczna
c = kolekcja, ordered, mutable, heterogeniczna
d = kolekcja, unordered, mutable, heterogeniczna
correct_ans = a

[pytanie 21]
question = Tupla od listy różni się:
a = tupla jest uporządkowana a lista nie
b = Lista jest uporządkowana a tupla nie
c = tupla jest mutowalna a lista nie
d = lista jest mutowalna a tupla nie
correct_ans = d